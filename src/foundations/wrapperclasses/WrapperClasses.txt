Wrapper Classes
======================================================================
Why and What

What is?
    - An object version of a primitive, eg. Integer, Double, Character, Boolean
    - Holds primitive value inside an object

Why Wrappers exist?
    - Some APIs expect objects rather than primitives
    - Wrappers can be null to mean "no value", primitives cannot be null

Habits & Trade-offs
    - Prefer primitives for plain calculations and flags
    - Use wrappers only when an API or design truly needs an object

==========================================================================

Autoboxing and Unboxing

Autoboxing
    - Java automatically converts a primitive to its wrapper when an object is expected

Unboxing
    - Java automatically converts a wrapper to its primitive when a primitive is expected

Where its used?
    - Assigning int into an Integer variable or passing it to a method that expects Integer

    - Using an Integer where an int is needed triggers unboxing
        Integer boxed = 7; // autoboxing
        int sum = boxed + 3; // unboxing then addition

Rules to keep code safe
    - Never unbox a null wrapper. Check for null and supply a default value.
        Eg. Integer boxed = null; // autoboxing
            int sum = boxed + 3; // unboxing then addition

    - Use equals for comparing wrapper values; use == for primitives

    - Avoid unnecessary boxing in tight loops or simple arithmetic

==========================================================================

In Java, a wrapper class is a class that "wraps" a primitive data type (like int, char, double, boolean)
into an object. For every primitive type, there is a corresponding wrapper class, such as Integer for int,
Character for char, Double for double, and Boolean for boolean.
Why wrapper classes are needed:
To treat primitive types as objects: Java's Collections Framework (e.g., ArrayList, HashMap) can only store objects,
not primitive types directly. Wrapper classes allow you to store primitive values within these collections by
wrapping them in objects.

    public class WrapperExample {
        public static void main(String[] args) {
            ArrayList<Integer> numbers = new ArrayList<>();
            numbers.add(10); // Autoboxing: int 10 is automatically converted to Integer object
            numbers.add(20);
            System.out.println(numbers);
        }
    }

To provide utility methods:
    - Wrapper classes offer various static utility methods that are not available to primitive types.
    For example, Integer.parseInt("123") converts a string to an int, and Double.toString(3.14)
    converts a double to a string.

To allow for null values:
    - Primitive types cannot be assigned null. Wrapper classes, being objects, can hold null values,
    which is useful in situations where a "not set" state needs to be represented, particularly in database
    interactions or when dealing with optional values.

Autoboxing and Unboxing:
    - Java automatically converts between primitive types and their corresponding wrapper objects
    (autoboxing and unboxing), simplifying code and making it more convenient to work with both.

In essence, wrapper classes bridge the gap between Java's primitive data types and its object-oriented nature,
enabling primitives to be used in contexts that require objects and providing additional functionalities.